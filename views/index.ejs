<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="stylesheet" href="/styles.css?v=<%= version %>">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PerfectRed</title>
  <link rel="icon" href="data:image/png;base64,<%= faviconBase64 %>" type="image/png">
  <style>
    .continue-section { margin: 40px 20px; }
    .section-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
    .section-title { font-size: 1.5em; font-weight: bold; color: #fff; }
    .reading-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px,1fr)); gap: 15px; }
    .reading-card { background:#000000;color:#fff;border-radius:12px;padding:10px;position:relative;cursor:pointer;transition:transform 0.1s,box-shadow 0.1s; }
    .reading-card:hover { transform:translateY(-3px); box-shadow:0 4px 12px rgba(0,0,0,0.5); }
    .remove-btn { position:absolute; top:6px; right:6px; background:transparent; border:none; color:#f55; font-size:16px; cursor:pointer; z-index:10; }
    .reading-card-title { margin-bottom:6px; }
    .series-name { font-weight:bold; font-size:1em; }
    .chapter-name { font-size:0.85em; color:#888; }
    .reading-card-info { font-size:0.85em; margin-bottom:4px; }
    .progress-bar { background:#555; height:6px; border-radius:3px; overflow:hidden; margin-bottom:6px; }
    .progress-fill { background:#f55; height:100%; width:0%; }
    .reading-card-time { font-size:0.75em; color:#aaa; }
    .empty-state { text-align: center; padding: 40px 20px; color: #888; }
    .empty-state-icon { font-size: 3em; margin-bottom: 10px; }
    .error-state { text-align: center; padding: 40px 20px; color: #f55; }
  </style>
</head>
<body>
  <div class="version-id" id="version"></div>
  <script>
    fetch("/version")
      .then(res => res.json())
      .then(data => {
        document.getElementById("version").textContent = "v" + data.version;
      });
  </script>
  
  <nav>
    <ul>
      <li><a href="/">Home</a></li>
      <li><a href="/library">Library</a></li>
      <li><a href="/statistics">Statistics</a></li>
      <li><a href="/webscrape">MangaDex</a></li>
      <li><a href="/settings">Settings</a></li>
    </ul>
  </nav>
  
  <center><h1 style="margin-top: 50px;">PerfectRed</h1></center>

  <div class="continue-section">
    <div class="section-header">
      <div class="section-title">Continue Reading</div>
    </div>
    <div id="continueReadingContainer">
      <div class="empty-state">
        <p>Loading...</p>
      </div>
    </div>
  </div>

  <div class="continue-section">
    <div class="section-header">
      <div class="section-title">Continue Watching</div>
    </div>
    <div id="continueWatchingContainer">
      <div class="empty-state">
        <p>Loading...</p>
      </div>
    </div>
  </div>

  <div class="server-info">
    <div class="server-info-label">Server Uptime</div>
    <div id="server-uptime">Loading...</div>
  </div>

  <script>
    async function apiRequest(url, options = {}) {
      try {
        const response = await fetch(url, {
          ...options,
          headers: {
            'Content-Type': 'application/json',
            ...options.headers
          }
        });
        
        if (!response.ok) {
          if (response.status === 401) {
            console.error('Not authenticated, redirecting to login...');
            window.location.href = '/login';
            return null;
          }
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        return await response.json();
      } catch (err) {
        console.error('API request failed:', err);
        throw err;
      }
    }

    class ReadingHistory {
      async getHistory() {
        try {
          const data = await apiRequest('/api/progress/reading');
          if (!data) return [];
          return data.success ? data.progress : [];
        } catch (err) {
          console.error('Error fetching reading history:', err);
          return [];
        }
      }

      async saveProgress(filePath, fileName, currentPage, totalPages, fileType = 'cbz') {
        try {
          await apiRequest('/api/progress/reading', {
            method: 'POST',
            body: JSON.stringify({ filePath, fileName, currentPage, totalPages, fileType })
          });
        } catch (err) {
          console.error('Error saving reading progress:', err);
        }
      }

      async removeItem(filePath) {
        try {
          await apiRequest('/api/progress/reading', {
            method: 'DELETE',
            body: JSON.stringify({ filePath })
          });
        } catch (err) {
          console.error('Error removing reading item:', err);
        }
      }

      getTimeAgo(isoString) {
        const date = new Date(isoString), now = new Date();
        const seconds = Math.floor((now - date) / 1000);
        if (seconds < 60) return 'Just now';
        if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
        if (seconds < 86400) {
          const hours = Math.floor(seconds / 3600);
          const mins = Math.floor((seconds % 3600) / 60);
          return `${hours}h ${mins}m ago`;
        }
        if (seconds < 604800) return `${Math.floor(seconds / 86400)}d ago`;
        return date.toLocaleDateString();
      }

      parseSeriesInfo(fileName, filePath = null) {
        const nameWithoutExt = fileName.replace(/\.(cbz|zip|epub|pdf)$/i, '');
        const patterns = [
          /^(.+?)\s*-\s*(?:Volume|Vol\.?)\s*(\d+(?:\.\d+)?)\s*-\s*(?:Chapter|Ch\.?)\s*(\d+(?:\.\d+)?)(?:\s*-\s*(.*))?$/i,
          /^(.+?)\s*-\s*(?:Volume|Vol\.?)\s*(\d+(?:\.\d+)?)(?:\s*-\s*(.*))?$/i,
          /^(.+?)\s*-\s*(?:Chapter|Ch\.?|Episode|Ep\.?)\s*(\d+(?:\.\d+)?)(?:\s*-\s*(.*))?$/i,
          /^(.+?)\s+(?:Volume|Vol\.?)\s*(\d+(?:\.\d+)?)\s+(?:Chapter|Ch\.?)\s*(\d+(?:\.\d+)?)(?:\s*-\s*(.*))?$/i,
          /^(.+?)\s+(?:Volume|Vol\.?)\s*(\d+(?:\.\d+)?)(?:\s*-\s*(.*))?$/i,
          /^(.+?)\s+(?:Chapter|Ch\.?|Episode|Ep\.?)\s*(\d+(?:\.\d+)?)(?:\s*-\s*(.*))?$/i,
          /^(.+?)\s*[\[\(](?:Volume|Vol\.?)\s*(\d+(?:\.\d+)?)(?:\s*-\s*(.*))?[\]\)]$/i,
          /^(.+?)\s*[\[\(](?:Chapter|Ch\.?|Episode|Ep\.?)\s*(\d+(?:\.\d+)?)(?:\s*-\s*(.*))?[\]\)]$/i,
          /^(?:Volume|Vol\.?)\s*(\d+(?:\.\d+)?)\s*-\s*(?:Chapter|Ch\.?)\s*(\d+(?:\.\d+)?)(?:\s*-\s*(.*))?$/i,
          /^(?:Volume|Vol\.?)\s*(\d+(?:\.\d+)?)(?:\s*-\s*(.*))?$/i,
          /^(?:Chapter|Ch\.?|Episode|Ep\.?)\s*(\d+(?:\.\d+)?)(?:\s*-\s*(.*))?$/i
        ];

        for (let i = 0; i < patterns.length; i++) {
          const pattern = patterns[i];
          const match = nameWithoutExt.match(pattern);
          
          if (match) {
            if (i === 0 || i === 3 || i === 8) {
              const seriesName = i === 8 ? 'Unknown Series' : match[1].trim();
              const volumeNum = i === 8 ? match[1].trim() : match[2].trim();
              const chapterNum = i === 8 ? match[2].trim() : match[3].trim();
              const suffix = i === 8 ? (match[3] || '').trim() : (match[4] || '').trim();
              
              let finalSeriesName = seriesName;
              if (i === 8 && filePath) {
                const pathParts = filePath.replace(/\\/g, '/').split('/');
                const cleanParts = pathParts.filter(p => p && p !== fileName);
                if (cleanParts.length > 0) {
                  finalSeriesName = cleanParts[cleanParts.length - 1];
                  if (finalSeriesName === 'data' && cleanParts.length > 1) {
                    finalSeriesName = cleanParts[cleanParts.length - 2];
                  }
                }
              }
              
              return {
                series: finalSeriesName,
                volume: parseFloat(volumeNum),
                volumeStr: volumeNum,
                chapter: parseFloat(chapterNum),
                chapterStr: chapterNum,
                suffix: suffix,
                display: `Volume ${volumeNum} - Chapter ${chapterNum}${suffix ? ' - ' + suffix : ''}`
              };
            }
            else if (i === 1 || i === 4 || i === 6 || i === 9) {
              const volumeNum = i === 9 ? match[1].trim() : match[2].trim();
              const suffix = i === 9 ? (match[2] || '').trim() : (match[3] || '').trim();
              
              let seriesName = i === 9 ? 'Unknown Series' : match[1].trim();
              
              if (i === 9 && filePath) {
                const pathParts = filePath.replace(/\\/g, '/').split('/');
                const cleanParts = pathParts.filter(p => p && p !== fileName);
                if (cleanParts.length > 0) {
                  seriesName = cleanParts[cleanParts.length - 1];
                  if (seriesName === 'data' && cleanParts.length > 1) {
                    seriesName = cleanParts[cleanParts.length - 2];
                  }
                }
              }
              
              return {
                series: seriesName,
                volume: parseFloat(volumeNum),
                volumeStr: volumeNum,
                chapter: null,
                chapterStr: null,
                suffix: suffix,
                display: `Volume ${volumeNum}${suffix ? ' - ' + suffix : ''}`
              };
            }
            else {
              const chapterNum = i === 10 ? match[1].trim() : match[2].trim();
              const suffix = i === 10 ? (match[2] || '').trim() : (match[3] || '').trim();
              
              let seriesName = i === 10 ? 'Unknown Series' : match[1].trim();
              
              if (i === 10 && filePath) {
                const pathParts = filePath.replace(/\\/g, '/').split('/');
                const cleanParts = pathParts.filter(p => p && p !== fileName);
                if (cleanParts.length > 0) {
                  seriesName = cleanParts[cleanParts.length - 1];
                  if (seriesName === 'data' && cleanParts.length > 1) {
                    seriesName = cleanParts[cleanParts.length - 2];
                  }
                }
              }
              
              return {
                series: seriesName,
                volume: null,
                volumeStr: null,
                chapter: parseFloat(chapterNum),
                chapterStr: chapterNum,
                suffix: suffix,
                display: `Chapter ${chapterNum}${suffix ? ' - ' + suffix : ''}`
              };
            }
          }
        }

        return {
          series: nameWithoutExt,
          volume: null,
          volumeStr: null,
          chapter: null,
          chapterStr: null,
          suffix: '',
          display: nameWithoutExt
        };
      }
    }

    class VideoHistory {
      async getHistory() {
        try {
          const data = await apiRequest('/api/progress/video');
          if (!data) return [];
          return data.success ? data.progress : [];
        } catch (err) {
          console.error('Error fetching video history:', err);
          return [];
        }
      }

      async saveProgress(filePath, fileName, currentTime, duration) {
        try {
          await apiRequest('/api/progress/video', {
            method: 'POST',
            body: JSON.stringify({ filePath, fileName, currentTime, duration })
          });
        } catch (err) {
          console.error('Error saving video progress:', err);
        }
      }

      async removeItem(filePath) {
        try {
          await apiRequest('/api/progress/video', {
            method: 'DELETE',
            body: JSON.stringify({ filePath })
          });
        } catch (err) {
          console.error('Error removing video item:', err);
        }
      }

      getTimeAgo(isoString) {
        const date = new Date(isoString), now = new Date();
        const seconds = Math.floor((now - date) / 1000);
        if (seconds < 60) return 'Just now';
        if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
        if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
        if (seconds < 604800) return `${Math.floor(seconds / 86400)}d ago`;
        return date.toLocaleDateString();
      }

      formatTime(seconds) {
        if (isNaN(seconds)) return '0:00';
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
      }

      parseSeriesInfo(fileName, filePath = null) {
        const nameWithoutExt = fileName.replace(/\.(webm|mp4|mkv|avi)$/i, '');
        const patterns = [
          /^(.+?)\s*-\s*(?:Season|S)\s*(\d+)\s*(?:Episode|Ep?\.?|E)\s*(\d+)(?:\s*-\s*(.*))?$/i,
          /^(.+?)\s*-\s*(?:Episode|Ep?\.?|E)\s*(\d+)(?:\s*-\s*(.*))?$/i,
          /^(.+?)\s+(?:Season|S)\s*(\d+)\s*(?:Episode|Ep?\.?|E)\s*(\d+)(?:\s*-\s*(.*))?$/i,
          /^(.+?)\s+(?:Episode|Ep?\.?|E)\s*(\d+)(?:\s*-\s*(.*))?$/i,
          /^(.+?)\s*[\[\(](?:Season|S)\s*(\d+)(?:Episode|Ep?\.?|E)\s*(\d+)[\]\)](?:\s*-\s*(.*))?$/i,
          /^(.+?)\s*[\[\(](?:Episode|Ep?\.?|E)\s*(\d+)[\]\)](?:\s*-\s*(.*))?$/i,
          /^(.+?)\s*S(\d+)E(\d+)(?:\s*-\s*(.*))?$/i,
          /^(.+?)\s*(\d+)x(\d+)(?:\s*-\s*(.*))?$/i,
          // New simple patterns - just episode number
          /^(?:Episode|Ep\.?)\s*(\d+)$/i,
          /^(?:Episode|Ep\.?)(\d+)$/i
        ];

        for (let i = 0; i < patterns.length; i++) {
          const pattern = patterns[i];
          const match = nameWithoutExt.match(pattern);
          
          if (match) {
            // Handle simple episode patterns (patterns 8 and 9)
            if (i === 8 || i === 9) {
              const episodeNum = match[1].trim();
              
              let seriesName = 'Unknown Series';
              if (filePath) {
                const pathParts = filePath.replace(/\\/g, '/').split('/');
                const cleanParts = pathParts.filter(p => p && p !== fileName);
                if (cleanParts.length > 0) {
                  seriesName = cleanParts[cleanParts.length - 1];
                  if (seriesName === 'data' && cleanParts.length > 1) {
                    seriesName = cleanParts[cleanParts.length - 2];
                  }
                }
              }
              
              return {
                series: seriesName,
                season: null,
                seasonStr: null,
                episode: parseInt(episodeNum),
                episodeStr: episodeNum,
                suffix: '',
                display: `Episode ${episodeNum}`
              };
            }
            // Original pattern handling for other formats
            else if (i === 0 || i === 2 || i === 4 || i === 6 || i === 7) {
              const seriesName = match[1].trim();
              const seasonNum = match[2].trim();
              const episodeNum = match[3].trim();
              const suffix = (match[4] || '').trim();
              
              return {
                series: seriesName,
                season: parseInt(seasonNum),
                seasonStr: seasonNum,
                episode: parseInt(episodeNum),
                episodeStr: episodeNum,
                suffix: suffix,
                display: `Season ${seasonNum} - Episode ${episodeNum}${suffix ? ' - ' + suffix : ''}`
              };
            } else {
              const seriesName = match[1].trim();
              const episodeNum = match[2].trim();
              const suffix = (match[3] || '').trim();
              
              return {
                series: seriesName,
                season: null,
                seasonStr: null,
                episode: parseInt(episodeNum),
                episodeStr: episodeNum,
                suffix: suffix,
                display: `Episode ${episodeNum}${suffix ? ' - ' + suffix : ''}`
              };
            }
          }
        }

        // Fallback - try to get series name from path
        let seriesName = nameWithoutExt;
        if (filePath) {
          const pathParts = filePath.replace(/\\/g, '/').split('/');
          const cleanParts = pathParts.filter(p => p && p !== fileName);
          if (cleanParts.length > 0) {
            seriesName = cleanParts[cleanParts.length - 1];
            if (seriesName === 'data' && cleanParts.length > 1) {
              seriesName = cleanParts[cleanParts.length - 2];
            }
          }
        }

        return {
          series: seriesName,
          season: null,
          seasonStr: null,
          episode: null,
          episodeStr: null,
          suffix: '',
          display: nameWithoutExt
        };
      }
    }

    const videoHistory = new VideoHistory();
    const readingHistory = new ReadingHistory();
    window.videoHistory = videoHistory;
    window.readingHistory = readingHistory;

    async function displayVideoHistory() {
      const container = document.getElementById('continueWatchingContainer');
      
      try {
        const history = await videoHistory.getHistory();
        const incomplete = history.filter(i => i.progress < 100);
        
        if (!incomplete.length) {
          container.innerHTML = '<div class="empty-state"><p>No videos in progress</p></div>';
          return;
        }

        const seriesMap = new Map();
        incomplete.forEach(item => {
          const info = videoHistory.parseSeriesInfo(item.file_name, item.file_path);
          const seriesKey = info.series;
          
          if (!seriesMap.has(seriesKey)) {
            seriesMap.set(seriesKey, { item, info });
          } else {
            const existing = seriesMap.get(seriesKey);
            if (new Date(item.last_watched) > new Date(existing.item.last_watched)) {
              seriesMap.set(seriesKey, { item, info });
            }
          }
        });

        const uniqueItems = Array.from(seriesMap.values())
          .sort((a, b) => new Date(b.item.last_watched) - new Date(a.item.last_watched));

        const cards = uniqueItems.map(({ item, info }) => {
          let episodeDisplay = '';
          if (info.seasonStr && info.episodeStr) {
            episodeDisplay = `<div class="chapter-name">Season ${info.seasonStr} - Episode ${info.episodeStr}${info.suffix ? ' - ' + info.suffix : ''}</div>`;
          } else if (info.episodeStr) {
            episodeDisplay = `<div class="chapter-name">Episode ${info.episodeStr}${info.suffix ? ' - ' + info.suffix : ''}</div>`;
          }
          
          return `
            <div class="reading-card" onclick="continueWatching('${item.file_path}', ${item.current_time})">
              <button class="remove-btn" onclick="event.stopPropagation(); removeVideoHistory('${item.file_path}')">×</button>
              <div class="reading-card-title" title="${info.display}">
                <div class="series-name">${info.series}</div>
                ${episodeDisplay}
              </div>
              <div class="reading-card-info">${videoHistory.formatTime(item.current_time)} / ${videoHistory.formatTime(item.duration)}</div>
              <div class="reading-card-info">${item.progress}% complete</div>
              <div class="progress-bar"><div class="progress-fill" style="width:${item.progress}%"></div></div>
              <div class="reading-card-time">${videoHistory.getTimeAgo(item.last_watched)}</div>
            </div>
          `;
        }).join('');

        container.innerHTML = `<div class="reading-grid">${cards}</div>`;
      } catch (err) {
        console.error('Failed to display video history:', err);
        container.innerHTML = '<div class="error-state"><div class="empty-state-icon">⚠️</div><p>Failed to load video history</p></div>';
      }
    }

    function continueWatching(filePath, startTime) {
      window.location.href = `/player?file=${encodeURIComponent(filePath)}&time=${startTime}`;
    }

    async function removeVideoHistory(filePath) {
      if (confirm('Remove this video from history?')) {
        await videoHistory.removeItem(filePath);
        displayVideoHistory();
      }
    }

    async function displayReadingHistory() {
      const container = document.getElementById('continueReadingContainer');
      
      try {
        const history = await readingHistory.getHistory();
        const incomplete = history.filter(i => i.progress < 100);
        
        if (!incomplete.length) {
          container.innerHTML = '<div class="empty-state"><p>No manga in progress</p></div>';
          return;
        }

        const seriesMap = new Map();
        incomplete.forEach(item => {
          const info = readingHistory.parseSeriesInfo(item.file_name, item.file_path);
          const seriesKey = info.series;
          
          if (!seriesMap.has(seriesKey)) {
            seriesMap.set(seriesKey, { item, info });
          } else {
            const existing = seriesMap.get(seriesKey);
            if (new Date(item.last_read) > new Date(existing.item.last_read)) {
              seriesMap.set(seriesKey, { item, info });
            }
          }
        });

        const uniqueItems = Array.from(seriesMap.values())
          .sort((a, b) => new Date(b.item.last_read) - new Date(a.item.last_read));

        const cards = uniqueItems.map(({ item, info }) => {
          let chapterDisplay = '';
          if (info.volumeStr && info.chapterStr) {
            chapterDisplay = `<div class="chapter-name">Volume ${info.volumeStr} - Chapter ${info.chapterStr}${info.suffix ? ' - ' + info.suffix : ''}</div>`;
          } else if (info.volumeStr) {
            chapterDisplay = `<div class="chapter-name">Volume ${info.volumeStr}${info.suffix ? ' - ' + info.suffix : ''}</div>`;
          } else if (info.chapterStr) {
            chapterDisplay = `<div class="chapter-name">Chapter ${info.chapterStr}${info.suffix ? ' - ' + info.suffix : ''}</div>`;
          }
          
          return `
            <div class="reading-card" onclick="continueReading('${item.file_path}','${encodeURIComponent(item.file_name)}',${item.current_page})">
              <button class="remove-btn" onclick="event.stopPropagation(); removeHistoryItem('${item.file_path}')">×</button>
              <div class="reading-card-title" title="${info.display}">
                <div class="series-name">${info.series}</div>
                ${chapterDisplay}
              </div>
              <div class="reading-card-info">Page <span class="red-number">${item.current_page}</span> of <span class="red-number">${item.total_pages}</span></div>
              <div class="reading-card-info">${item.progress}% complete</div>
              <div class="progress-bar"><div class="progress-fill" style="width:${item.progress}%"></div></div>
              <div class="reading-card-time">${readingHistory.getTimeAgo(item.last_read)}</div>
            </div>
          `;
        }).join('');

        container.innerHTML = `<div class="reading-grid">${cards}</div>`;
      } catch (err) {
        console.error('Failed to display reading history:', err);
        container.innerHTML = '<div class="error-state"><div class="empty-state-icon">⚠️</div><p>Failed to load reading history</p></div>';
      }
    }

    function continueReading(filePath, fileName, startPage) {
      window.location.href = `/reader?file=${encodeURIComponent(filePath)}&name=${fileName}&page=${startPage}`;
    }

    async function removeHistoryItem(filePath) {
      await readingHistory.removeItem(filePath);
      displayReadingHistory();
    }

    function updateUptime() {
      fetch('/api/uptime')
        .then(res => {
          if (!res.ok) throw new Error('Failed to fetch uptime');
          return res.json();
        })
        .then(data => {
          const el = document.getElementById('server-uptime');
          if (el) {
            const parts = [];
            if (data.days > 0) parts.push(`${data.days}d`);
            if (data.hours > 0) parts.push(`${data.hours}h`);
            if (data.minutes > 0) parts.push(`${data.minutes}m`);
            parts.push(`${data.seconds}s`);
            el.textContent = parts.join(' ');
          }
        })
        .catch(err => {
          console.error('Error fetching uptime:', err);
          const el = document.getElementById('server-uptime');
          if (el) el.textContent = 'Error';
        });
    }

    async function initializePage() {
      try {
        await Promise.all([
          displayVideoHistory(),
          displayReadingHistory()
        ]);
        updateUptime();
        setInterval(updateUptime, 1000);
      } catch (err) {
        console.error('Error initializing page:', err);
      }
    }

    initializePage();
  </script>
  <div class="version-id"><%= version %></div>
</body>
</html>