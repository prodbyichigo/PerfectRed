<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="data:image/png;base64,<%= faviconBase64 %>" type="image/png">
  <title>PerfectRed</title>
  <link rel="stylesheet" href="/styles.css?v=<%= version %>">
</head>
<body>
  <!-- Header -->
  <header class="reader-header" id="header">
    <div class="header-content">
      <a href="/" class="back-btn">← Home</a>
      <div class="book-title" id="bookTitle">Loading...</div>
      <div class="page-counter" id="pageCounter">-/-</div>
    </div>
  </header>

  <!-- Reader Container -->
  <div class="reader-container" id="readerContainer">
    <div class="loading">
      <div class="spinner"></div>
      Loading...
    </div>
  </div>

  <!-- Navigation Areas (Desktop only) -->
  <div class="nav-area nav-left" id="navLeft" onclick="previousPage()">
    <div class="nav-icon">‹</div>
  </div>
  
  <div class="nav-area nav-center" id="navCenter" onclick="toggleControls()"></div>
  
  <div class="nav-area nav-right" id="navRight" onclick="nextPage()">
    <div class="nav-icon">›</div>
  </div>

  <!-- Mobile tap zones -->
  <div class="mobile-tap-zone mobile-tap-left" onclick="previousPage()"></div>
  <div class="mobile-tap-zone mobile-tap-center" onclick="toggleControls()"></div>
  <div class="mobile-tap-zone mobile-tap-right" onclick="nextPage()"></div>

  <!-- Bottom Controls -->
  <div class="bottom-controls" id="bottomControls">
    <div class="controls-content">
      <button class="control-btn" id="firstBtn" onclick="firstPage()">First</button>
      <button class="control-btn" id="prevBtn" onclick="previousPage()">Previous</button>
      
      <div class="page-slider">
        <input type="range" id="pageSlider" min="1" max="1" value="1" oninput="goToPage(this.value)">
        <div style="text-align: center; font-size: 12px; color: #ccc;">
          Page <span id="currentPage">1</span> of <span id="totalPages">1</span>
        </div>
      </div>
      
      <button class="control-btn" id="nextBtn" onclick="nextPage()">Next</button>
      <button class="control-btn" id="lastBtn" onclick="lastPage()">Last</button>
    </div>
  </div>

  <!-- Next Chapter Prompt -->
  <div id="nextChapterPrompt" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9); padding: 30px; border-radius: 10px; z-index: 10000; text-align: center; color: white;">
    <h2 style="margin-bottom: 20px;">Chapter Complete!</h2>
    <p id="nextChapterInfo" style="margin-bottom: 20px;"></p>
    <button onclick="loadNextChapter()" style="background: #e74c3c; color: white; border: none; padding: 12px 24px; border-radius: 5px; cursor: pointer; font-size: 16px; margin-right: 10px;">Load Next Chapter</button>
    <button onclick="closeNextChapterPrompt()" style="background: #555; color: white; border: none; padding: 12px 24px; border-radius: 5px; cursor: pointer; font-size: 16px;">Stay Here</button>
  </div>

  <!-- Include JSZip library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  
  <script>
    let currentImages = [];
    let currentPage = 0;
    let isControlsVisible = false;
    let touchStartX = 0;
    let touchStartY = 0;
    let isMobile = window.innerWidth <= 768;
    let nextChapterPath = null;

    // Reading History Class
    class ReadingHistory {
      constructor() {
        this.storageKey = 'perfectred_reading_history';
        this.maxItems = 10;
      }

      saveProgress(filePath, fileName, currentPage, totalPages, fileType = 'cbz') {
        try {
          let history = this.getHistory();
          const existingIndex = history.findIndex(item => item.filePath === filePath);

          const item = {
            filePath,
            fileName,
            currentPage,
            totalPages,
            fileType,
            lastRead: new Date().toISOString(),
            progress: Math.round((currentPage / totalPages) * 100)
          };

          if (existingIndex >= 0) {
            history[existingIndex] = item;
          } else {
            history.unshift(item);
          }

          history = history.slice(0, this.maxItems);
          localStorage.setItem(this.storageKey, JSON.stringify(history));
          return true;
        } catch (e) {
          console.error('Error saving history:', e);
          return false;
        }
      }

      getHistory() {
        try {
          const data = localStorage.getItem(this.storageKey);
          return data ? JSON.parse(data) : [];
        } catch (e) {
          return [];
        }
      }

      getProgress(filePath) {
        const history = this.getHistory();
        return history.find(item => item.filePath === filePath);
      }

      parseSeriesInfo(fileName) {
        const nameWithoutExt = fileName.replace(/\.(cbz|zip|epub|pdf)$/i, '');

        const patterns = [
          // "Series - Chapter 7 - Subtitle" or "Series - Chapter 7"
          /^(.+?)\s*-\s*(?:Chapter|Ch\.?|Episode|Ep\.?)\s*(\d+(?:\.\d+)?)(?:\s*-\s*(.*))?$/i,
          // "Series Chapter 7 - Subtitle" or "Series Chapter 7"
          /^(.+?)\s+(?:Chapter|Ch\.?|Episode|Ep\.?)\s*(\d+(?:\.\d+)?)(?:\s*-\s*(.*))?$/i,
          // "[Chapter 7 - Subtitle]" or "(Chapter 7)"
          /^(.+?)\s*[\[\(](?:Chapter|Ch\.?|Episode|Ep\.?)\s*(\d+(?:\.\d+)?)(?:\s*-\s*(.*))?[\]\)]$/i,
          // "Chapter 185 - Stomach in Another World" (chapter-first format)
          /^(?:Chapter|Ch\.?|Episode|Ep\.?)\s*(\d+(?:\.\d+)?)(?:\s*-\s*(.*))?$/i
        ];

        for (let i = 0; i < patterns.length; i++) {
          const pattern = patterns[i];
          const match = nameWithoutExt.match(pattern);
          
          if (match) {
            // Handle chapter-first format differently
            if (i === 3) {
              const chapterNum = match[1].trim();
              const subtitle = match[2] ? match[2].trim() : '';
              
              return {
                series: subtitle || 'Unknown Series',
                chapter: parseFloat(chapterNum),
                chapterStr: chapterNum,
                suffix: '',
                display: `Ch. ${chapterNum}${subtitle ? ' - ' + subtitle : ''}`
              };
            } else {
              // Handle series-first formats
              const seriesName = match[1].trim();
              const chapterNum = match[2].trim();
              const suffix = match[3] ? match[3].trim() : '';
              
              return {
                series: seriesName,
                chapter: parseFloat(chapterNum),
                chapterStr: chapterNum,
                suffix: suffix,
                display: `${seriesName} - Ch. ${chapterNum}${suffix ? ' - ' + suffix : ''}`
              };
            }
          }
        }

        // Fallback: just grab any number
        const numberMatch = nameWithoutExt.match(/(\d+(?:\.\d+)?)/);
        if (numberMatch) {
          return {
            series: nameWithoutExt.replace(numberMatch[0], '').trim(),
            chapter: parseFloat(numberMatch[0]),
            chapterStr: numberMatch[0],
            suffix: '',
            display: nameWithoutExt
          };
        }

        return {
          series: nameWithoutExt,
          chapter: null,
          chapterStr: null,
          suffix: '',
          display: nameWithoutExt
        };
      }
    }

    const readingHistory = new ReadingHistory();

    // Get file path from URL parameters
    const urlParams = new URLSearchParams(window.location.search);
    const filePath = urlParams.get('file');
    const fileName = urlParams.get('name') || 'Unknown';
    const startPage = parseInt(urlParams.get('page')) || 1;

    // Parse and display series info
    const seriesInfo = readingHistory.parseSeriesInfo(fileName);
    document.getElementById('bookTitle').textContent = seriesInfo.display;

    if (!filePath) {
      showError('No file specified');
    } else {
      loadFile(filePath).then(() => {
        findNextChapter();
      });
    }

    window.addEventListener('resize', () => {
      isMobile = window.innerWidth <= 768;
    });

    function saveProgress() {
      if (filePath && currentImages.length > 0) {
        readingHistory.saveProgress(
          filePath,
          fileName,
          currentPage + 1,
          currentImages.length,
          'cbz'
        );
      }
    }

    // Find next chapter in the same folder
    async function findNextChapter() {
      if (seriesInfo.chapter === null) return;

      try {
        const pathParts = filePath.split('/');
        const folderPath = pathParts.slice(0, -1).join('/');

        const response = await fetch(`/api/folder?path=${encodeURIComponent(folderPath)}`);
        if (!response.ok) return;

        const data = await response.json();
        const files = data.files || [];

        // Parse all files and extract their info
        const seriesFiles = files
          .map(f => ({ ...f, info: readingHistory.parseSeriesInfo(f.name) }))
          .filter(f => f.info.chapter !== null);

        // If current file uses chapter-first format (no clear series name),
        // assume all files in the same folder are part of the same series
        const isChapterFirstFormat = /^(?:Chapter|Ch\.?|Episode|Ep\.?)\s*\d+/i.test(fileName);

        let matchingFiles;
        
        if (isChapterFirstFormat) {
          // For chapter-first format, match ALL files with chapter numbers in the same folder
          matchingFiles = seriesFiles.filter(f => {
            const fileIsChapterFirst = /^(?:Chapter|Ch\.?|Episode|Ep\.?)\s*\d+/i.test(f.name);
            return fileIsChapterFirst;
          });
        } else {
          // For series-first format, match by series name
          matchingFiles = seriesFiles.filter(f => f.info.series === seriesInfo.series);
        }

        // Sort by chapter number
        matchingFiles.sort((a, b) => a.info.chapter - b.info.chapter);

        // Find current file index
        const currentIndex = matchingFiles.findIndex(f => {
          const normalizedFPath = decodeURIComponent(f.path.replace(/^data\//, ''));
          const normalizedFilePath = decodeURIComponent(filePath.replace(/^data\//, ''));
          return normalizedFPath === normalizedFilePath;
        });

        // Check if there's a next chapter
        if (currentIndex >= 0 && currentIndex < matchingFiles.length - 1) {
          const nextFile = matchingFiles[currentIndex + 1];
          nextChapterPath = nextFile.path;

          // Add arrow indicator
          const pageCounter = document.getElementById('pageCounter');
          const currentHTML = pageCounter.innerHTML.replace(/ <span.*?▶<\/span>/, '');
          pageCounter.innerHTML = currentHTML + ' <span style="color: #e74c3c; font-size: 0.8em;">▶</span>';
        }
      } catch (err) {
        console.error('Error finding next chapter:', err);
      }
    }

    function loadNextChapter() {
      if (nextChapterPath) {
        const nextFileName = nextChapterPath.split('/').pop();
        window.location.href = `/reader?file=${encodeURIComponent(nextChapterPath)}&name=${encodeURIComponent(nextFileName)}&page=1`;
      }
    }

    async function loadFile(filePath) {
      try {
        const response = await fetch('/file/' + encodeURIComponent(filePath));
        if (!response.ok) throw new Error('Failed to load file');

        const arrayBuffer = await response.arrayBuffer();
        const zip = await JSZip.loadAsync(arrayBuffer);

        const imageFiles = [];
        const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp'];

        zip.forEach((relativePath, file) => {
          if (!file.dir) {
            const ext = relativePath.toLowerCase().substring(relativePath.lastIndexOf('.'));
            if (imageExtensions.includes(ext)) {
              imageFiles.push({ name: relativePath, file: file });
            }
          }
        });

        if (imageFiles.length === 0) {
          throw new Error('No images found in this file');
        }

        imageFiles.sort((a, b) => a.name.localeCompare(b.name, undefined, {numeric: true}));
        currentImages = imageFiles;

        const savedProgress = readingHistory.getProgress(filePath);
        if (startPage > 1) {
          currentPage = startPage - 1;
        } else if (savedProgress && savedProgress.currentPage > 0) {
          currentPage = savedProgress.currentPage - 1;
        } else {
          currentPage = 0;
        }

        if (currentPage >= currentImages.length) currentPage = 0;

        updatePageSlider();
        await displayCurrentPage();

      } catch (err) {
        showError(err.message);
      }
    }

    async function displayCurrentPage() {
      if (currentImages.length === 0) return;

      const container = document.getElementById('readerContainer');
      container.innerHTML = '<div class="loading"><div class="spinner"></div>Loading page...</div>';

      try {
        const imageFile = currentImages[currentPage];
        const imageData = await imageFile.file.async('blob'); 
        const objectUrl = URL.createObjectURL(imageData);

        container.innerHTML = `
          <div class="image-container">
            <img alt="Page ${currentPage + 1}" class="reader-image">
          </div>
        `;

        const img = container.querySelector("img");
        img.src = objectUrl;

        img.onload = () => {
          URL.revokeObjectURL(objectUrl);
        };

        updateUI();
        saveProgress();

      } catch (err) {
        showError('Failed to load page: ' + err.message);
      }
    }

    function updateUI() {
      document.getElementById('pageCounter').textContent = `${currentPage + 1}/${currentImages.length}`;
      document.getElementById('currentPage').textContent = currentPage + 1;
      document.getElementById('totalPages').textContent = currentImages.length;
      document.getElementById('pageSlider').value = currentPage + 1;

      document.getElementById('firstBtn').disabled = currentPage === 0;
      document.getElementById('prevBtn').disabled = currentPage === 0;
      document.getElementById('nextBtn').disabled = currentPage === currentImages.length - 1 && !nextChapterPath;
      document.getElementById('lastBtn').disabled = currentPage === currentImages.length - 1 && !nextChapterPath;
    }

    function updatePageSlider() {
      const slider = document.getElementById('pageSlider');
      slider.max = currentImages.length;
      slider.value = currentPage + 1;
    }

    function previousPage() {
      if (currentPage > 0) {
        currentPage--;
        displayCurrentPage();
      }
    }

    function nextPage() {
      if (currentPage < currentImages.length - 1) {
        currentPage++;
        displayCurrentPage();
      } else if (nextChapterPath) {
        loadNextChapter();
      }
    }

    function firstPage() {
      currentPage = 0;
      displayCurrentPage();
    }

    function lastPage() {
      currentPage = currentImages.length - 1;
      displayCurrentPage();
    }

    function goToPage(pageNum) {
      currentPage = parseInt(pageNum) - 1;
      displayCurrentPage();
    }

    function toggleControls() {
      const controls = document.getElementById('bottomControls');
      isControlsVisible = !isControlsVisible;
      controls.classList.toggle('visible', isControlsVisible);
    }

    function showError(message) {
      document.getElementById('readerContainer').innerHTML = `
        <div class="error">
          <div class="error-icon">⚠️</div>
          <h2>Error</h2>
          <p>${message}</p>
          <br>
          <a href="/library" class="back-btn">Back to Library</a>
        </div>
      `;
    }

    // Keyboard navigation
    document.addEventListener('keydown', (e) => {
      if (currentImages.length === 0) return;

      switch(e.key) {
        case 'ArrowLeft':
        case 'ArrowUp':
        case 'PageUp':
          e.preventDefault();
          previousPage();
          break;
        case 'ArrowRight':
        case 'ArrowDown':
        case 'PageDown':
        case ' ':
          e.preventDefault();
          nextPage();
          break;
        case 'Home':
          e.preventDefault();
          firstPage();
          break;
        case 'End':
          e.preventDefault();
          lastPage();
          break;
        case 'Escape':
          e.preventDefault();
          window.location.href = '/library';
          break;
      }
    });
    document.body.addEventListener('touchmove', function(e) {
      e.preventDefault();
    }, { passive: false });

    document.addEventListener('touchstart', (e) => {
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    }, { passive: true });

    document.addEventListener('touchend', (e) => {
      if (!touchStartX || !touchStartY) return;

      const touchEndX = e.changedTouches[0].clientX;
      const touchEndY = e.changedTouches[0].clientY;

      const diffX = touchStartX - touchEndX;
      const diffY = touchStartY - touchEndY;

      if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 80) {
        e.preventDefault();
        if (diffX > 0) {
          nextPage();
        } else {
          previousPage();
        }
      }

      touchStartX = 0;
      touchStartY = 0;
    }, { passive: false });
    window.addEventListener('beforeunload', saveProgress);
  </script>
  <div class="version-id"><%= version %></div>
</body>
</html>